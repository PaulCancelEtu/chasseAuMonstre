<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Game.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Coverage Report</a> &gt; <a href="index.source.html" class="el_package">model.maze</a> &gt; <span class="el_source">Game.java</span></div><h1>Game.java</h1><pre class="source lang-java linenums">package model.maze;

import java.util.Arrays;

import fr.univlille.iutinfo.cam.player.hunter.IHunterStrategy;
import fr.univlille.iutinfo.cam.player.monster.IMonsterStrategy;
import fr.univlille.iutinfo.cam.player.perception.ICoordinate;
import fr.univlille.iutinfo.cam.player.perception.ICellEvent.CellInfo;
import model.maze.observer.IObserver;
import model.maze.observer.Subject;
import model.maze.roles.Hunter;
import model.maze.roles.Monster;
import model.maze.roles.Role;
import model.maze.util.StringBuildableSubject;

/**
 * Classe principale de notre jeu. Elle gère la grille de jeu et les actions des rôles
 * sur la partie.
 */

public class Game extends StringBuildableSubject implements IObserver {
	private Hunter hunter;
	private Monster monster;
	private int exactTurn;
	private Cell[][] maze;

	public static final int ROLE_COUNT = 2;
	public static final int TURN_MONSTER = 0;
	public static final int TURN_HUNTER = 1;

	/**
	 * Instancie une nouvelle partie selon le tableau de {@code CellInfo} donné en 
	 * paramètres et applique les stratégies données aux rôles différents.
	 * 
	 * @param grid la grille de jeu
	 * @param hunterStrategy la stratégie du chasseur
	 * @param monsterStrategy la stratégie du monstre
	 * @throws NoMonsterCellException si la grille ne contient aucun {@code CellInfo.MONSTER}
	 */
<span class="fc" id="L40">	public Game(CellInfo[][] grid, IHunterStrategy hunterStrategy, IMonsterStrategy monsterStrategy) {</span>
<span class="fc" id="L41">		this.exactTurn = 0;</span>

<span class="fc" id="L43">		Cell monsterCell = this.initializeMaze(grid);</span>
		
<span class="fc" id="L45">		this.monster = new Monster(monsterStrategy, monsterCell);</span>
<span class="fc" id="L46">		this.monster.attach(this);</span>
<span class="fc" id="L47">		this.attach(monster);</span>

<span class="fc" id="L49">		this.hunter = new Hunter(hunterStrategy);</span>
<span class="fc" id="L50">		this.hunter.attach(this);</span>
<span class="fc" id="L51">		this.attach(hunter);</span>

<span class="fc" id="L53">		CellEvent monsterCellEvent = new CellEvent(CellInfo.MONSTER, monsterCell);</span>
<span class="fc" id="L54">		monsterCellEvent.setTurn(0);</span>
<span class="fc" id="L55">		monsterCell.setLastEvent(monsterCellEvent);</span>
		
<span class="fc" id="L57">		this.exactTurn = ROLE_COUNT; // init at turn 1 == exactTurn / ROLE_COUNT</span>
<span class="fc" id="L58">	}</span>

	/**
	 * Instancie une nouvelle partie selon le tableau de {@code CellInfo} donné en 
	 * paramètres en mode Joueur vs IA, le joueur étant le monstre et l'IA le chasseur.
	 * 
	 * @param grid la grille de jeu
	 * @param hunterStrategy la stratégie du chasseur
	 * @throws NoMonsterCellException si la grille ne contient aucun {@code CellInfo.MONSTER}
	 */
	public Game(CellInfo[][] grid, IHunterStrategy hunterStrategy) {
<span class="nc" id="L69">		this(grid, hunterStrategy, null);</span>
<span class="nc" id="L70">	}</span>

	/**
	 * Instancie une nouvelle partie selon le tableau de {@code CellInfo} donné en 
	 * paramètres en mode Joueur vs IA, le joueur étant le chasseur et l'IA le monstre.
	 * 
	 * @param grid la grille de jeu
	 * @param monsterStrategy la stratégie du monstre
	 * @throws NoMonsterCellException si la grille ne contient aucun {@code CellInfo.MONSTER}
	 */
	public Game(CellInfo[][] grid, IMonsterStrategy monsterStrategy) {
<span class="nc" id="L81">		this(grid, null, monsterStrategy);</span>
<span class="nc" id="L82">	}</span>

	/**
	 * Instancie une nouvelle partie selon le tableau de {@code CellInfo} donné en 
	 * paramètre en mode Joueur vs Joueur.
	 * 
	 * @param grid la grille de jeu
	 * @throws NoMonsterCellException si la grille ne contient aucun {@code CellInfo.MONSTER}
	 */
	public Game(CellInfo[][] grid) {
<span class="fc" id="L92">		this(grid, null, null);</span>
<span class="fc" id="L93">	}</span>

	
	/**
	 * Remplis la grille de jeu avec des cellules neuves.
	 * 
	 * @param grid la grille de jeu
	 * @throws NoMonsterCellException si la grille ne contient aucun {@code CellInfo.MONSTER}
	 */
	private Cell initializeMaze(CellInfo[][] grid) {
<span class="fc" id="L103">		int lengthRow = grid.length;</span>
<span class="fc" id="L104">		int lengthCol = grid[0].length;</span>
<span class="fc" id="L105">		Cell monsterCell = null;</span>

<span class="fc" id="L107">		this.maze = new Cell[lengthRow][lengthCol];</span>

<span class="fc bfc" id="L109" title="All 2 branches covered.">		for (int i = 0; i &lt; lengthRow; i++) {</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">			for (int j = 0; j &lt; lengthCol; j++) {</span>
<span class="fc" id="L111">				this.maze[i][j] = new Cell(i, j, grid[i][j]);</span>

<span class="fc bfc" id="L113" title="All 2 branches covered.">				if (grid[i][j] == CellInfo.MONSTER) {</span>
<span class="fc" id="L114">					monsterCell = this.maze[i][j];</span>
				}
			}
		}

<span class="fc bfc" id="L119" title="All 2 branches covered.">		if (monsterCell == null) {</span>
<span class="fc" id="L120">			throw new NoMonsterCellException();</span>
		}

<span class="fc" id="L123">		return monsterCell;</span>
	}

	/**
	 * Traite un évènement de jeu. Cette méthode est appelée lorsqu'un des rôles 
	 * attaché à Game exécute sa méthode {@code play}. 
	 * 
	 * &lt;p&gt;Si c'est au tour du rôle en question et que les paramètres donnés sont 
	 * cohérents et ne violent pas les règles du jeu, alors l'indice de tour 
	 * s'incrémente et les observateurs attachés sont notifiés avec l'évènement.&lt;/p&gt;
	 * 
	 * &lt;p&gt;Si ce tour correspond à une victoire d'un des deux rôles selon les règles
	 * du jeu, alors les observateurs attachés sont notifiés une deuxième fois
	 * mais avec le rôle gagnant.&lt;/p&gt;
	 * 
	 * @param role le rôle qui a joué
	 * @param event l'évènement créé par ce rôle
	 */
	protected void processRoleEvent(Role role, CellEvent event) {
<span class="fc" id="L142">		ICoordinate coord = event.getCoord();</span>

<span class="fc bfc" id="L144" title="All 2 branches covered.">		if (!this.isInBorders(coord)) return; // raise exception ?</span>
		
<span class="fc" id="L146">		boolean victory = false;</span>
<span class="fc" id="L147">		Cell targetCell = this.getCell(coord);</span>

<span class="fc bfc" id="L149" title="All 2 branches covered.">		if (role.equals(this.monster)) {</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">			if (!this.monster.canPlay(targetCell)) return; // raise exception ?</span>

<span class="fc" id="L152">			victory = targetCell.isExit();</span>
<span class="fc" id="L153">		} else {</span>
<span class="fc" id="L154">			Cell monsterCell = this.getMonsterCell();</span>

<span class="fc" id="L156">			victory = targetCell.equals(monsterCell);</span>
		}

<span class="fc" id="L159">		event.setTurn(this.getTurn());</span>

<span class="fc" id="L161">		this.exactTurn++;</span>
<span class="fc" id="L162">		this.notifyObservers(event);</span>
<span class="fc" id="L163">		targetCell.setLastEvent(event);</span>

<span class="fc bfc" id="L165" title="All 2 branches covered.">		if (victory) {</span>
<span class="fc" id="L166">			this.notifyObservers(role);</span>
		}
<span class="fc" id="L168">	}</span>

	/**
	 * Indique si les coordonnées données sont dans les bornes de la grille
	 * 
	 * @param coord la cordonnée en question
	 * @return si les coordonnées données sont dans les bornes de la grille ou non
	 */
	public boolean isInBorders(ICoordinate coord) {
<span class="pc bpc" id="L177" title="2 of 4 branches missed.">		return coord.getCol() &gt;= 0</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">				&amp;&amp; coord.getRow() &gt;= 0</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">				&amp;&amp; coord.getCol() &lt; this.getNbCols()</span>
<span class="fc" id="L180">				&amp;&amp; coord.getRow() &lt; this.getNbRows();</span>
	}

	public Monster getMonster() {
<span class="fc" id="L184">		return this.monster;</span>
	}

	/**
	 * Indique le rôle auquel le tour est selon l'indice de tour donné en paramètres.
	 * Retourne le monstre si l'indice de tour est pair, le chasseur autrement.
	 * 
	 * @param exactTurn l'indice de tour
	 * @return le rôle auquel le tour est
	 */
	private Role getTurnRole(int exactTurn) {
<span class="pc bpc" id="L195" title="1 of 3 branches missed.">		switch (exactTurn % ROLE_COUNT) {</span>
			case TURN_MONSTER:
<span class="fc" id="L197">				return this.monster;</span>
			case TURN_HUNTER:
<span class="fc" id="L199">				return this.hunter;</span>
			default:
<span class="nc" id="L201">				return null;</span>
		}
	}

	/**
	 * Indique le rôle auquel le tour est.
	 * 
	 * @return le rôle auquel le tour est
	 */
	public Role getCurrentTurnRole() {
<span class="fc" id="L211">		return this.getTurnRole(this.exactTurn);</span>
	}

	/**
	 * Indique le nombre de lignes de la grille de jeu
	 * 
	 * @return le nombre de lignes de la grille de jeu
	 */
	public int getNbRows() {
<span class="fc" id="L220">		return this.maze.length;</span>
	}

	/**
	 * Indique le nombre de colonnes de la grille de jeu
	 * 
	 * @return le nombre de colonnes de la grille de jeu
	 */
	public int getNbCols() {
<span class="fc" id="L229">		return this.maze[0].length;</span>
	}

	public Hunter getHunter() {
<span class="fc" id="L233">		return this.hunter;</span>
	}

	/**
	 * Renvoie le numéro de tour actuel.
	 * Un tour passe lorsque tous les rôles ont joué.
	 * 
	 * @return le numéro de tour actuel
	 */
	public int getTurn() {
<span class="fc" id="L243">		return this.exactTurn / ROLE_COUNT;</span>
	}

	/**
	 * Renvoie l'indice de tour actuel.
	 * L'indice de tour est incrémenté lorsqu'un rôle joue.
	 * 
	 * @return l'indice de tour actuel
	 */
	public int getExactTurn() {
<span class="fc" id="L253">		return this.exactTurn;</span>
	}
	
	/**
	 * Renvoie une cellule de notre grille selon la ligne et la colonne données en paramètres.
	 * 
	 * @param row la ligne de la cellule
	 * @param col la colonne de la celulle
	 * @return la celulle aux coordonnées données
	 * @throws ArrayIndexOutOfBoundsException si les coordonnées sont en dehors des bornes de la grille de jeu
	 */
	public Cell getCell(int row, int col) {
<span class="fc" id="L265">		return this.maze[row][col];</span>
	}

	/**
	 * Renvoie une cellule de notre grille selon les coordonnées données en paramètres.
	 * 
	 * @param coord les coordonnées
	 * @return la celulle aux coordonnées données
	 * @throws ArrayIndexOutOfBoundsException si les coordonnées sont en dehors des bornes de la grille de jeu
	 */
	public Cell getCell(ICoordinate coord) {
<span class="fc" id="L276">		return this.getCell(coord.getRow(), coord.getCol());</span>
	}

	/**
	 * Indique la cellule sur laquelle le monstre se trouve actuellement.
	 * 
	 * @return la cellule sur laquelle le monstre se trouve actuellement
	 */
	public Cell getMonsterCell() {
<span class="fc" id="L285">		return this.getCell(this.monster.getCoord());</span>
	}

	@Override
<span class="nc" id="L289">	public void update(Subject subj) {} // non-utilisé</span>

	@Override
	public void update(Subject subj, Object data) {
<span class="pc bpc" id="L293" title="1 of 4 branches missed.">		if (subj.equals(this.monster) || subj.equals(this.hunter)) {</span>
<span class="fc" id="L294">			this.processRoleEvent((Role) subj, (CellEvent) data);</span>
		}
<span class="fc" id="L296">	}</span>

	@Override
	public void fillStringBuilder(StringBuilder sb) {
<span class="fc" id="L300">		sb.append(this.getExactTurn());</span>
<span class="fc" id="L301">		sb.append(&quot; (&quot;);</span>
<span class="fc" id="L302">		sb.append(this.getTurn());</span>
<span class="fc" id="L303">		sb.append(&quot;);&quot;);</span>
<span class="fc" id="L304">		sb.append(this.getMonster());</span>
<span class="fc" id="L305">		sb.append(this.getHunter());</span>
<span class="fc" id="L306">	}</span>
	
	@Override
	public boolean equals(Object obj) {
<span class="fc bfc" id="L310" title="All 2 branches covered.">		if (obj == null)</span>
<span class="fc" id="L311">			return false;</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">		if (obj == this)</span>
<span class="fc" id="L313">			return true;</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">		if (!(obj instanceof Game))</span>
<span class="nc" id="L315">			return false;</span>

<span class="fc" id="L317">		Game other = (Game) obj;</span>
		
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">		return this.monster.equals(other.monster)</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">			&amp;&amp; this.hunter.equals(other.hunter)</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">			&amp;&amp; Arrays.equals(this.maze, other.maze)</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">			&amp;&amp; this.exactTurn == other.exactTurn;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>