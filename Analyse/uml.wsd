@startuml sae302
scale 2
skinparam classAttributeIconSize 0
skinparam ClassBackgroundColor Cornsilk
skinparam RoundCorner 0
skinparam ClassBorderColor Black
hide circle

interface IStrategy <<Interface>> {
	+play(): ICoordinate
	+update(event: ICellEvent): void
}

interface IMonsterStrategy <<Interface>> extends IStrategy {
	+initialize(maze: boolean[][]): void
}

interface IHunterStrategy <<Interface>> extends IStrategy {
	+initialize(nbRows: int, nbCols:int): void
}


Interface ICellEvent<<Interface>> {
	+getState(): CellInfo
	+getTurn(): int
	+getCoord(): ICoordinate
}

Interface ICoordinate<<Interface>>{
	+getRow(): int
	+getCol(): int 
}

enum CellInfo<<Enum>>{
	EMPTY
	WALL
	MONSTER
	HUNTER
	EXIT
}

package model.maze {
	package observer {
		abstract class Subject {
			+attach(observer: IObserver): void
			+detach(observer: IObserver): void
			#notifyObservers(data: Object): void
			#notifyObservers(): void
		}

		interface IObserver <<Interface>> {
			update(subject: Subject): void
			update(subject: Subject, data: Object): void
		}
	}
	
	package util {
		interface IStringBuildable <<Interface>> {
			+fillStringBuilder(sb: StringBuilder): void
		}

		class StringBuildables {
			-StringBuildables()
			
			+stringBuildableToString(object: IStringBuildable): String
		}

		abstract class StringBuildable implements IStringBuildable {
			+toString(): String
		}

		abstract class StringBuildableSubject extends Subject implements IStringBuildable {
			+toString(): String
		}
	}

	class Cell extends Coordinate {
		#Cell(row: int, col: int, state: CellInfo)

		+getState(): CellInfo
		+getTurn(): int
		+getUpdatedState(): CellInfo
		setLastEvent(event: ICellEvent): void
		+isTravelable(): bool
		+isExit(): bool
	}

	package roles {
		class Hunter extends Role {
			+Hunter(strategy: IHunterStrategy)
			+Hunter()
			
			+getStrategy(): IHunterStrategy
		}

		abstract class Role extends StringBuildableSubject implements IObserver {
			+play(): void
			{abstract} +play(coord: ICoordinate): void
			' => la stratégie retourne la coordonnée : l'entité créé un évènement de cellule pour que la plateforme la manipule
			#updateStrategy(event: ICellEvent): void
			+hasStrategy(): boolean
		}

		class Monster extends Role {
			+Monster(cell: Cell)
			+Monster(cell: Cell, strategy: IMonsterStrategy)

			+getCell(): Cell
			-setCell(cell: Cell): void
			+getStrategy(): IMonsterStrategy
		}
	}

	enum Level <<Enum>> {
		LEVEL_1
		LEVEL_2
		LEVEL_3

		-grid: CellInfo[][]

		-Level(grid: CellInfo[][])

		+getNbRows(): int
		+getNbCols(): int
		+getCellInfo(row: int, col: int): CellInfo
		+getGrid(): CellInfo[][]
	}

	' package strategies {
	' 	interface INullStrategy <<Interface>> extends IStrategy {}

	' 	class NullMonsterStrategy implements INullStrategy, IMonsterStrategy {
	' 		+NullMonsterStrategy()
	' 	}
	' 	class NullHunterStrategy implements INullStrategy, IHunterStrategy {
	' 		+NullHunterStrategy()
	' 	}
	' }

' 	Quelle est la meilleure pratique : 
' 1) garder tel quel, càd utiliser une valeur nulle lorsque le joueur joue
' 2) supprimer le constructeur +Monster(cell: Cell)  et créer une classe NullMonsterStrategy lorsque le joueur joue
' 3) supprimer le constructeur +Monster(cell: Cell) et forcer à ce qu'on mette "null" pour instancier un Monster

	class Game extends StringBuildableSubject implements IObserver {
		+{static} ROLE_COUNT: int
		+{static} TURN_MONSTER: int
		+{static} TURN_HUNTER: int
		-exactTurn: int
		-maze: Cell[][]

		+Game(grid: CellInfo[][],\n\t    hunterStrategy: IHunterStrategy, \n\t    monsterStrategy: IMonsterStrategy)
		+Game(grid: CellInfo[][],\n\t    hunterStrategy: IHunterStrategy)
		+Game(grid: CellInfo[][],\n\t    monsterStrategy: IMonsterStrategy)
		+Game(grid: CellInfo[][])

		-initializeMaze(grid: CellInfo[][]): Cell
		#processRoleEvent(role: Role, event: CellEvent): void
		+isInBorders(coord: ICoordinate): boolean
		+getNbRows(): int
		+getNbCols(): int
		+getTurn(): int
		+getExactTurn(): int
		+getCell(coord: ICoordinate): Cell
		+getCell(row: int, col: int): Cell
		-getTurnRole(turn: int): Role
		+getCurrentTurnRole(): Role
		+getHunter(): Hunter
		+getMonster(): Monster
		+getMonsterCell(): Cell
	}


	class CellEvent extends StringBuildable implements ICellEvent {
		{static} INIT_TURN: int
		-turn: int

		+CellEvent(state: CellInfo, coord: ICoordinate)
		
		setTurn(turn: int): void
	}

	class Coordinate extends StringBuildable implements ICoordinate {
		-ROW: int
		-COL: int

		+Coordinate(row: int, col: int)
	}
}

Subject --> " *  \n" IObserver : " # observers"

Cell -> CellInfo : " - STATE"
Cell --> ICellEvent : " - lastEvent"

Monster --> Cell : " - cell"
CellEvent -> CellInfo : " - STATE"
CellEvent -> ICoordinate : " - COORD"

Game -> Hunter : " - hunter"
Game -> Monster : " - monster"
Role ---> IStrategy : " # strategy"

@enduml

